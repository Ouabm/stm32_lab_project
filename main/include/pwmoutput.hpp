#ifndef RT_PWMOUTPUT_HPP
#define RT_PWMOUTPUT_HPP

#include <cadmium/modeling/devs/atomic.hpp>
#include <limits>
#include <iostream>
#include <algorithm>
#include "stm32h7xx_hal.h" // Adapt this include depending on your STM32 series (e.g., stm32f1xx_hal.h)

using namespace std;

namespace cadmium
{

    // State structure for the PWM output model
    struct PWMOutputState
    {
        double output; // Current PWM duty cycle [0.0, 1.0]
        double sigma;  // Time until next internal event (unused here)

        explicit PWMOutputState() : output(0.0), sigma(1.0) {}
    };

    // Stream output operator for debugging the PWM duty cycle
    std::ostream &operator<<(std::ostream &out, const PWMOutputState &state)
    {
        out << "PWM Output Duty Cycle: " << state.output;
        return out;
    }

    /**
     * PWMOutput: A DEVS atomic model to control a PWM output channel on an STM32 timer.
     * It listens to input duty cycle commands (between 0 and 1) and sets the timer compare register accordingly.
     */
    class PWMOutput : public Atomic<PWMOutputState>
    {
    public:
        Port<double> in;          // Input port for duty cycle commands
        TIM_HandleTypeDef *timer; // Pointer to initialized STM32 timer handle (e.g., &htim3)
        uint32_t channel;         // Timer channel to control (e.g., TIM_CHANNEL_1)
        uint32_t period_ticks;    // Timer period in timer ticks

        /**
         * Constructor
         * @param id - Unique model identifier
         * @param t - Pointer to the initialized timer handle
         * @param ch - Timer channel constant (e.g., TIM_CHANNEL_1)
         * @param period - Timer period (in ticks)
         */
        PWMOutput(const std::string &id, TIM_HandleTypeDef *t, uint32_t ch, uint32_t period)
            : Atomic<PWMOutputState>(id, PWMOutputState()), timer(t), channel(ch), period_ticks(period)
        {
            in = addInPort<double>("in");

            // Assume HAL_TIM_PWM_Start() has already been called in main.c or setup code
            setPWMDutyCycle(0.0); // Initialize with 0% duty cycle (off)
        }

        /**
         * Internal transition: no internal state changes needed
         */
        void internalTransition(PWMOutputState &state) const override
        {
            // No internal events
        }

        /**
         * External transition: on receiving new duty cycle input, clamps it and updates PWM output
         */
        void externalTransition(PWMOutputState &state, double e) const override
        {
            if (!in->empty())
            {
                for (const auto &x : in->getBag())
                {
                    state.output = std::clamp(x, 0.0, 1.0); // Clamp input between 0 and 1
                }
                setPWMDutyCycle(state.output);
            }
        }

        /**
         * Output function: no output messages generated by this model
         */
        void output(const PWMOutputState &state) const override
        {
            // No DEVS output here
        }

        /**
         * Time advance: model waits indefinitely for external events
         */
        [[nodiscard]] double timeAdvance(const PWMOutputState &state) const override
        {
            return std::numeric_limits<double>::infinity();
        }

    private:
        /**
         * Helper function to update the timer compare register with the given duty cycle
         * @param duty Duty cycle in range [0.0, 1.0]
         */
        void setPWMDutyCycle(double duty) const
        {
            uint32_t compare = static_cast<uint32_t>(duty * period_ticks);
            __HAL_TIM_SET_COMPARE(timer, channel, compare); // Write compare value to PWM duty cycle register
        }
    };
}

#endif // RT_PWMOUTPUT_HPP
